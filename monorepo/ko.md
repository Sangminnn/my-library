# monorepo

- npm, yarn, pnpm이 대표적인 package manager이다.

- npm, yarn classic은 패키지를 hoisting하여 평탄화 시키는 과정을 가진다. yarn classic이 hosting하는 과정속에서 기존에는 1 depth로 접근할 수 없던 라이브러리임에도 불구하고, 이를 접근할 수 있게되는데 이를 직접 의존하고 있지 않은 라이브러리를 require할 수 있다하여 유령 의존성이라고 부른다. 이는 반대로 다른 의존성을 제거하게 되었을 때 인지하지 못한 상태로 제거될 수 있다는 점에서 문제를 일으킬 가능성이 있다.

- yarn berry는 이를 해결하기 위한 pnp(Plug'n'play)방식을 제공했는데, 이는 node_modules를 사용하지 않고, cache폴더에 의존성 정보를 zip형태로 저장하여 메모리를 최소화할 수 있고, **.pnp.cjs** 에 의존성을 찾을 수 있는 정보를 기록한다. 이를 이용해 디스크 I/O 없이 어떤 패키지가 어떤 라이브러리에 의존하는지, 각 라이브러리는 어디에 위치하는지를 알 수 있다. 또한 zip파일을 이용함으로써 중복설치를 방지할 수도 있다.

- 의존성을 버전 관리에 포함하는 것을 Zero-install이라고 한다. 이를 통해 저장소를 새로 복제 및 브랜치를 변경하더라도 yarn install을 실행하지 않아도 된다. git clone으로 저장소를 복제했을 때에도 의존성들이 바로 사용 가능한 상태였기때문에 의존성을 설치할 필요가 없다. (.yarn/cache에 zip파일들이 존재)

- pnpm은 기존의 npm, yarn classic에서 하는 방식인 hoisting을 통한 flat한 파일관리 (flat하게 만들면 depth를 타고가지 않아도 되어 디스크 I/O가 줄어 성능이 향상된다.) 방식을 벗어나 기존 패키지들이 가지고있는 nested한 구조를 그대로 유지하면서 실제 설치되는 의존성 패키지들은 디스크에 저장해두고, 이를 가지고올 수 있는 주소인 symlink를 연결해두어 중복 설치를 제거하고 성능을 향상한 방법을 사용한다.

- 위 3가지 패키지는 모두 lock파일을 가지고 있는데, 일단 lock 파일의 정의를 먼저 살펴보면, lock 파일이란 매 설치시 결정적이고 (= 항상 같은 버전을 설치하고) 예측가능한 특성을 보장하기 위하여, 각 버전의 정확한 의존성 버전을 저장하고 있는 파일을 의미한다. package.json은 정확한 버전이 기재되어 있는 것이 아니고, >= 1.2.5와 같은 형식의 버전 범위 aka 시멘틱 버저닝이 존재하기 때문에, lock파일이 없다면 매 설치마다 설치하는 버전이 달라질 수 있다.

- corepack은 node 16 lts 버전부터 정식으로 포함되었으며, npm, yarn, pnpm과 같은 package manager들의 manager라고 볼 수 있다. 이러한 패키지 매니저를 중간에서 관리해주는 layer역할로서 각 패키지 매니저를 별도로 설치할 필요없이 사용 및 변경할 때 유용하다.

- monorepo를 구성하기위해서는 일반적으로 package manager, package manager로부터 만들어낸 여러가지 workspace 관리하기 쉽도록 해주는 툴을 사용한다. 해당 종류는 lerna, turbo 등이 있다.

- turbo를 활용했을때 일반적으로 각 workspace끼리 코드를 공유하는것은 문제가 없으나 이를 배포할때에는 번들링이 따로 필요함. 최근에는 esbuild를 기반으로 한 tsup 이라는 번들러도 좋음. 이는 typescript 패키지를 간단한 설정으로 번들링할 수 있도록 해준다.
