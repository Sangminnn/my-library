# Network

# HTTP 1.0

- 한 연결당 하나의 요청을 처리하도록 설계
- 매 요청마다 새로 연결 및 응답을 받으면 연결을 닫는 형태를 가지고있어 비효율적임
- 헤더 및 본문이 같은 연결을 통해 전

# HTTP 1.1

- Persistent Connections : 여러 요청과 응답을 하나의 연결에서 처리할 수 있도록 함
  - **keep-alive** 라는 옵션으로 일정 시간동안 연결 상태를 유지
- Pipelining : 여러 요청을 동시에 보내고, 응답을 기다리지 않고 다음 요청을 보낼 수 있음.
  - 다만 이전에 보낸 요청에 대한 응답 순서는 유효하기때문에, 앞에서 병목이 생기면 뒤의 요청에 모두 병목이 생긴다. (Head Of Line Blocking)
  - 연속한 요청에서 헤더중복이 많이 일어남 (매 요청마다 헤더를 보내기 때문)

# HTTP 2.0

- Multiplexing(다중화) : 하나의 연결에서 동시에 여러 요청과 응답을 처리할 수 있음

  - HTTP 1.1의 Pipelining은 한번의 연결 내에서 여러 요청을 보낼 수 있었지만, 동시에 여러 요청을 처리하지는 못함
  - 하나의 커넥션 내에 여러개의 Stream (양방향 데이터 흐름) 을 사용하여 송수신
  - Binary Frame (이진 프레임) : 헤더와 데이터를 이진으로 인코딩하여 더 효율적인 전송이 가능
  - 인코딩된 데이터를 각 요청의 Stream 을 통해 전달하여, 하나의 커넥션 안에 여러개의 Stream 을 가질 수 있어 다중화가 가능해짐
  - Stream 을 사용하여 전송하기 때문에 각 요청의 응답 순서가 의미가 없어져 HOL Blocking 문제를 어느정도 해소

- Header Compression (헤더 압축)
  - 요청 및 응답 헤더의 메타데이터를 압축해서 기존의 연속된 요청에서의 중복 헤더로 인한 오버헤드 문제를 해결 - 대역폭을 절약
- Server Push (서버 푸시)
  - 클라이언트가 서버에 요청하지 않더라도 클라이언트에게 필요한 리소스를 서버가 추가적으로 Push 해줄 수 있음.
- 다만 서로 다른 Stream이 전송되고 있을 때, 하나의 Stream에서 유실이 발생하거나 문제가 생기면 결국 다른 Stream도 문제가 해결될 때 까지 지연되는 현상은 존재 ( **TCP 고유의 HOL Blocking** )

## 이 시점에서 해결이 필요했던 문제

- 헤더 정보를 압축했지만 더 고성능의 압축이 필요
- TCP 기반으로 인한 HOL Blocking 의 개선
- TCP 기반으로 인한 긴 초기 연결 설정 시간 (3-way handshake)

### TCP (Transmission Control Protocol)

- Connection Oriented : 통신을 시작하기 전에 연결을 설정, 통신이 끝나면 연결을 해제
  - 이로 인해 오버헤드가 발생할 수 있음.
  - 또한 연결상태를 유지하기 위한 리소스로 인해 대규모 연결은 관리하기 어려움
- 정확한 데이터 전송을 보장 : 데이터 전송 중 손실된 패킷을 재전송 및 순서를 보장
- Flow Control : 수신자가 처리할 수 있는 속도로 데이터 전송, 과다한 데이터 손실을 방지

# HTTP 3.0

- TCP 기반에서 UDP 기반의 QUIC 계층을 기반으로 하는 방식
  - TCP 기반의 장점이면서 문제점인 초기 연결 시의 **3-way handshaking 과정을 사용하지 않아 RTT가 감소** ( 이전에 통신한 경험이 있다면 0-RTT, 초기 연결이라면 1-RTT 로 연결 가능 )
  - TCP 의 Stream 처럼 하나의 Chain 으로 연결되는 것과 달리 **각 Stream 당 독립적인 Chain을 구성**하여 **TCP 의 HOL Blocking 을 개선**
  - 유연한 순서 제어를 제공 - 패킷 손실 및 지연이 발생했을 때 빠르게 대응할 수 있도록 설계되어있고 순서 제어 기능을 통해 웹 페이지 로딩 시간을 최소화, 성능을 향상 (중요한 데이터를 먼저 전송하도록 할 수도 있다.)
- HTTP 2.0 에서보다 **헤더를 더 압축하여 성능 개선**

# **SSL프로토콜의 핸드셰이크**

1. Client Hello :클라이언트가 서버로 요청을 보낸다. 랜덤한 데이터를 생성하여 전송하고 서버에서 어떤 암호화 방식을 지원하는지에 대한 여부도 같이 보낸다. (자기 PR)
2. Server Hello : 서버에서도 랜덤한 데이터를 클라이언트로 보내면서 클라이언트가 PR한 암호화 방식 중 하나를 선택하여 전달하고, 이에 대한 인증서도 같이 보냄. 이 인증서를 클라이언트가 복호화하면 서버에서 만든 공개키를 확인할 수 있다.
3. 클라이언트에서 인증서를 받으면 서명된 인증기관의 공개키를 통해 복호화, 이를 통해 서버의 공개키를 취득한다. 검증 실패라면 신뢰할 수 없는 페이지로 간주 (CA라면 검증된 인증서 발급처로 이해하면 좋다.)
4. 이제는 대칭키 방식으로 통신할 준비를 한다. 최초 통신 시 보낸 랜덤 데이터와 서버로부터 받은 랜덤 데이터를 사용하여 Pre-Master-Key를 생성, 이를 가지고 대칭키로 사용한다. 따라서 이 Pre-Master-Key를 가지고있는 공개키로 암호화하여 서버에 보낸다.
5. 서버는 받아온 암호화된 Pre-Master-Key를 비공개키로 복호화한다.
6. 클라이언트와 서버는 Pre-Master-Key와 Client Hello, Server Hello의 데이터를 조합하여 Master-Key를 각각 독립적으로 생성한다. 이 키는 동일하고 이것이 통신에 사용되는 **세션 키**로 사용된다.
