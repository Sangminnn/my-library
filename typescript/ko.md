# typescript

- 타입스크립트의 집합관계는 일반적으로 Array와 같은 타입에서는 슈퍼타입과 서브타입의 관계가 일반적인 형태인 하위 타입에서 상위 타입으로의 할당이 가능한 형태를 가지지만, 함수의 인자에서는 반대의 형태인 상위 타입에서 하위 타입으로의 할당이 가능한 형태를 가진다. 이를 전자는 공변성, 후자를 반공변성이라 부른다. 이는 **--strictFunctionTypes** 옵션을 사용한다면 함수 파라미터가 반공변적으로 동작한다. 이변성은 파라미터에서 이 두가지 성격을 다 가지는 것.
- 이에 대해 첨언하자면 타입관점에서는 긴가민가하지만 해당 타입의 범주보다 작은 범주를 할당할 경우, 기존에 선언된 타입에 따라 나머지 범주가 들어오는 경우를 처리하는 케이스가 있을 수 있음. 정적 타입과 동적으로 변하는 타입의 관점에서 생각하면 이해가 된다. 정적인 값을 넣어준다면 문제가 없지만, 기존의 동적 타입을 받아 처리해주는 부분에서는 공변성을 유지하게된다면 런타임에러가 발생할 가능성이 있음. 예를 들어 string | number 를 처리하는 함수에 number 만 처리할 수 있는 함수를 할당하게 된다면 런타임에 타입 문제가 생길 것이 자명하다. 해당 함수는 모든 파라미터를 number 로 보고 처리할텐데 실제로 string 타입까지 들어올 수 있는 것이기 때문이다.
- JavaScript의 Array 인스턴스는 다양한 메서드를 편리하게 지원하기 위해 메서드형태는 이변성을 가진다. (메서드는 일반 클래스 및 인터페이스(예: Array<T>)가 대부분 가변적으로 계속 관련되도록 하기 위해 특별히 제외되었습니다.)
- 줄여쓰기(shorthand) 방식(set(item: T): void;)은 메서드 파라미터를 이변적으로 동작시키기 위한 표기법이고, 프로퍼티 방식(set: (item: T) => void;)은 메서드 파라미터를 반공변적으로 동작시키기 위한 표기법
